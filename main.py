
import os
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, Poll
from telegram.constants import ParseMode, ChatType
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    PollAnswerHandler,
    ContextTypes,
    JobQueue
)
import json
import random
from datetime import datetime, time
import pytz
import asyncio
from typing import Dict, Set, Tuple, Optional

from pdf_manager import PDFManager

# Configuration du logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

class BotState:
    """Classe pour g√©rer l'√©tat global du bot."""
    def __init__(self):
        self.quiz_sessions: Dict = {}
        self.group_scores: Dict = {}
        self.active_polls: Dict = {}
        self.active_groups: Set = set()
        self.questions_data: list = []
        self.motivational_quotes: list = []
        
        # Configuration
        self.TELEGRAM_TOKEN = os.getenv("TOKEN")
        self.BOT_CREATOR_ID = int(os.getenv("BOT_CREATOR_ID", "6692408502"))
        
        # Canaux et groupes obligatoires
        self.REQUIRED_CHANNEL = "@kabro_edu"
        self.REQUIRED_GROUP = "@kabroedu"
        self.REQUIRED_CHANNEL_ID = -1002716550843
        self.REQUIRED_GROUP_ID = -1002391261450
        
        # Fichiers de sauvegarde
        self.SCORES_FILE = 'group_scores.json'
        self.ACTIVE_GROUPS_FILE = 'active_groups.json'
        
        # Initialiser le gestionnaire PDF
        self.pdf_manager = PDFManager()

class SubscriptionManager:
    """Gestionnaire des v√©rifications d'abonnement."""
    
    def __init__(self, bot_state: BotState):
        self.bot_state = bot_state
    
    async def check_user_subscription(self, context: ContextTypes.DEFAULT_TYPE, user_id: int) -> Tuple[bool, str]:
        """V√©rifie si l'utilisateur est abonn√© au canal et au groupe requis."""
        try:
            # V√©rifier l'abonnement au canal
            try:
                channel_member = await context.bot.get_chat_member(self.bot_state.REQUIRED_CHANNEL_ID, user_id)
                channel_subscribed = channel_member.status in ['member', 'administrator', 'creator']
                logger.info(f"Utilisateur {user_id} - Canal: {channel_member.status}")
            except Exception as e:
                error_msg = str(e).lower()
                if "user not found" in error_msg:
                    logger.warning(f"Utilisateur {user_id} non trouv√© dans le canal")
                    channel_subscribed = False
                elif any(keyword in error_msg for keyword in ["forbidden", "member list is inaccessible"]):
                    logger.warning(f"Canal {self.bot_state.REQUIRED_CHANNEL_ID} - Acc√®s limit√©")
                    # Ne pas donner acc√®s automatique en cas d'erreur
                    channel_subscribed = False
                else:
                    logger.error(f"Erreur v√©rification canal: {e}")
                    channel_subscribed = False

            # V√©rifier l'abonnement au groupe
            try:
                group_member = await context.bot.get_chat_member(self.bot_state.REQUIRED_GROUP_ID, user_id)
                group_subscribed = group_member.status in ['member', 'administrator', 'creator']
                logger.info(f"Utilisateur {user_id} - Groupe: {group_member.status}")
            except Exception as e:
                error_msg = str(e).lower()
                if "user not found" in error_msg:
                    logger.warning(f"Utilisateur {user_id} non trouv√© dans le groupe")
                    group_subscribed = False
                elif any(keyword in error_msg for keyword in ["forbidden", "member list is inaccessible"]):
                    logger.warning(f"Groupe {self.bot_state.REQUIRED_GROUP_ID} - Acc√®s limit√©")
                    group_subscribed = False
                else:
                    logger.error(f"Erreur v√©rification groupe: {e}")
                    group_subscribed = False

            if channel_subscribed and group_subscribed:
                logger.info(f"Utilisateur {user_id} v√©rifi√© avec succ√®s")
                return True, ""

            # Messages d'erreur selon ce qui manque
            if not channel_subscribed and not group_subscribed:
                message = (
                    "‚ùå ABONNEMENT REQUIS ‚ùå\n\n"
                    "üö´ Pour utiliser ce bot, vous devez √™tre abonn√© √† :\n\n"
                    f"üì¢ Canal : {self.bot_state.REQUIRED_CHANNEL}\n"
                    f"üë• Groupe : {self.bot_state.REQUIRED_GROUP}\n\n"
                    "‚úÖ Abonnez-vous puis r√©essayez !"
                )
            elif not channel_subscribed:
                message = (
                    "‚ùå ABONNEMENT AU CANAL REQUIS ‚ùå\n\n"
                    f"üì¢ Veuillez vous abonner au canal : {self.bot_state.REQUIRED_CHANNEL}\n\n"
                    "‚úÖ Abonnez-vous puis r√©essayez !"
                )
            else:
                message = (
                    "‚ùå ABONNEMENT AU GROUPE REQUIS ‚ùå\n\n"
                    f"üë• Veuillez rejoindre le groupe : {self.bot_state.REQUIRED_GROUP}\n\n"
                    "‚úÖ Rejoignez-nous puis r√©essayez !"
                )

            return False, message

        except Exception as e:
            logger.error(f"Erreur critique v√©rification abonnement: {e}")
            return False, "‚ùå Erreur de v√©rification. R√©essayez plus tard."

class DataManager:
    """Gestionnaire des donn√©es (sauvegarde/chargement)."""
    
    def __init__(self, bot_state: BotState):
        self.bot_state = bot_state
    
    def load_motivational_quotes(self):
        """Charge les citations motivantes depuis citations_motivantes.json"""
        try:
            with open('citations_motivantes.json', 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.bot_state.motivational_quotes = data.get('citations', [])
            logger.info(f"Charg√© {len(self.bot_state.motivational_quotes)} citations motivantes")
        except FileNotFoundError:
            logger.warning("Fichier citations_motivantes.json introuvable")
            self._load_default_quotes()
        except json.JSONDecodeError as e:
            logger.error(f"Format JSON invalide dans citations_motivantes.json: {e}")
            self._load_default_quotes()
        except Exception as e:
            logger.error(f"Erreur chargement citations: {e}")
            self._load_default_quotes()
    
    def _load_default_quotes(self):
        """Charge des citations par d√©faut."""
        self.bot_state.motivational_quotes = [
            "üí™ Le succ√®s, c'est 1% d'inspiration et 99% de transpiration. - Thomas Edison",
            "üéØ Un objectif sans plan n'est qu'un souhait. - Antoine de Saint-Exup√©ry",
            "üåü L'√©ducation est l'arme la plus puissante pour changer le monde. - Nelson Mandela",
            "üìö Celui qui ouvre une porte d'√©cole ferme une prison. - Victor Hugo",
            "üöÄ Il n'y a pas d'ascenseur vers le succ√®s, il faut prendre les escaliers. - Zig Ziglar"
        ]
    
    def load_questions(self):
        """Charge les questions depuis questions.json"""
        try:
            with open('questions.json', 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.bot_state.questions_data = data.get('histoire_geographie', [])
            logger.info(f"Charg√© {len(self.bot_state.questions_data)} questions")
            
            if not self.bot_state.questions_data:
                logger.warning("Aucune question trouv√©e dans le fichier JSON")
        except FileNotFoundError:
            logger.error("Fichier questions.json introuvable")
            self.bot_state.questions_data = []
        except json.JSONDecodeError as e:
            logger.error(f"Format JSON invalide dans questions.json: {e}")
            self.bot_state.questions_data = []
        except Exception as e:
            logger.error(f"Erreur chargement questions: {e}")
            self.bot_state.questions_data = []
    
    def save_scores(self):
        """Sauvegarde les scores dans un fichier JSON."""
        try:
            scores_to_save = {}
            for group_id, users in self.bot_state.group_scores.items():
                scores_to_save[str(group_id)] = {str(user_id): score for user_id, score in users.items()}
            
            with open(self.bot_state.SCORES_FILE, 'w', encoding='utf-8') as f:
                json.dump(scores_to_save, f, indent=2)
            logger.info(f"Scores sauvegard√©s pour {len(self.bot_state.group_scores)} groupes")
        except Exception as e:
            logger.error(f"Erreur sauvegarde scores: {e}")
    
    def load_scores(self):
        """Charge les scores depuis le fichier JSON."""
        try:
            with open(self.bot_state.SCORES_FILE, 'r', encoding='utf-8') as f:
                scores_data = json.load(f)
            
            self.bot_state.group_scores = {}
            for group_id_str, users in scores_data.items():
                group_id = int(group_id_str)
                self.bot_state.group_scores[group_id] = {int(user_id_str): score for user_id_str, score in users.items()}
            
            logger.info(f"Scores charg√©s pour {len(self.bot_state.group_scores)} groupes")
        except FileNotFoundError:
            logger.info("Aucun fichier de scores trouv√©, d√©marrage avec scores vides")
            self.bot_state.group_scores = {}
        except Exception as e:
            logger.error(f"Erreur chargement scores: {e}")
            self.bot_state.group_scores = {}
    
    def save_active_groups(self):
        """Sauvegarde la liste des groupes actifs."""
        try:
            with open(self.bot_state.ACTIVE_GROUPS_FILE, 'w', encoding='utf-8') as f:
                json.dump(list(self.bot_state.active_groups), f)
            logger.info(f"Groupes actifs sauvegard√©s: {len(self.bot_state.active_groups)} groupes")
        except Exception as e:
            logger.error(f"Erreur sauvegarde groupes actifs: {e}")
    
    def load_active_groups(self):
        """Charge la liste des groupes actifs."""
        try:
            with open(self.bot_state.ACTIVE_GROUPS_FILE, 'r', encoding='utf-8') as f:
                active_groups_list = json.load(f)
            self.bot_state.active_groups = set(active_groups_list)
            logger.info(f"Groupes actifs charg√©s: {len(self.bot_state.active_groups)} groupes")
        except FileNotFoundError:
            logger.info("Aucun fichier de groupes actifs trouv√©")
            self.bot_state.active_groups = set()
        except Exception as e:
            logger.error(f"Erreur chargement groupes actifs: {e}")
            self.bot_state.active_groups = set()
    
    async def periodic_save(self):
        """Sauvegarde p√©riodique des donn√©es."""
        while True:
            try:
                self.save_scores()
                self.save_active_groups()
                await asyncio.sleep(300)  # Toutes les 5 minutes
            except Exception as e:
                logger.error(f"Erreur sauvegarde p√©riodique: {e}")
                await asyncio.sleep(60)  # R√©essayer dans 1 minute

class QuizManager:
    """Gestionnaire des quiz."""
    
    def __init__(self, bot_state: BotState):
        self.bot_state = bot_state
    
    def get_random_questions(self, count: int = 3) -> list:
        """S√©lectionne des questions al√©atoirement avec v√©rification."""
        if not self.bot_state.questions_data:
            logger.warning("Aucune question disponible pour le quiz")
            return []
        
        available_count = min(count, len(self.bot_state.questions_data))
        return random.sample(self.bot_state.questions_data, available_count)
    
    async def start_quiz_in_group(self, context: ContextTypes.DEFAULT_TYPE, group_id: int, 
                                  trigger_message=None, is_daily=False):
        """D√©marre un quiz dans un groupe."""
        try:
            # V√©rifier si un quiz est d√©j√† actif
            if group_id in self.bot_state.quiz_sessions:
                if trigger_message:
                    await trigger_message.reply_text(
                        "‚ö†Ô∏è Quiz d√©j√† en cours !\n\n"
                        "üìù Attendez la fin du quiz actuel avant d'en d√©marrer un nouveau."
                    )
                return

            if not self.bot_state.questions_data:
                if trigger_message:
                    await trigger_message.reply_text(
                        "‚ùå Aucune question disponible\n\n"
                        "üîß Les questions sont en cours de chargement."
                    )
                return

            # Initialiser le groupe dans les scores si n√©cessaire
            if group_id not in self.bot_state.group_scores:
                self.bot_state.group_scores[group_id] = {}

            # Ajouter le groupe aux groupes actifs
            self.bot_state.active_groups.add(group_id)

            # S√©lectionner 3 questions al√©atoirement
            selected_questions = self.get_random_questions(3)
            
            if not selected_questions:
                if trigger_message:
                    await trigger_message.reply_text(
                        "‚ùå Aucune question disponible\n\n"
                        "üîß Les questions sont en cours de chargement."
                    )
                return

            # Cr√©er la session de quiz
            session_id = f"{'daily_' if is_daily else ''}quiz_{group_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            self.bot_state.quiz_sessions[group_id] = {
                'session_id': session_id,
                'questions': selected_questions,
                'current_question': 0,
                'total_questions': len(selected_questions),
                'participants': set(),
                'is_daily': is_daily
            }

            # Message d'introduction
            intro_text = (
                f"üéØ QUIZ {'QUOTIDIEN ' if is_daily else ''}D'HISTOIRE-G√âOGRAPHIE üéØ\n\n"
                f"üìö {len(selected_questions)} questions vous attendent !\n"
                "‚è∞ 30 secondes par question\n"
                "üåü 1 point par bonne r√©ponse\n\n"
                "üöÄ Premi√®re question :"
            )

            if trigger_message:
                await trigger_message.reply_text(intro_text)
            else:
                await context.bot.send_message(chat_id=group_id, text=intro_text)

            # D√©marrer imm√©diatement la premi√®re question
            await self.send_quiz_question(context, group_id)

            logger.info(f"Quiz {'quotidien ' if is_daily else ''}d√©marr√© dans le groupe {group_id}")

        except Exception as e:
            logger.error(f"Erreur d√©marrage quiz: {e}")
    
    async def send_quiz_question(self, context: ContextTypes.DEFAULT_TYPE, group_id: int):
        """Envoie une question de quiz."""
        try:
            if group_id not in self.bot_state.quiz_sessions:
                return

            session = self.bot_state.quiz_sessions[group_id]
            current_q = session['current_question']

            if current_q >= session['total_questions']:
                await self.end_quiz(context, group_id)
                return

            question_data = session['questions'][current_q].copy()

            # Limiter la longueur de la question et de l'explication
            question_text = question_data['question']
            if len(question_text) > 200:
                question_text = question_data['question'][:200] + "..."

            explanation = question_data['explanation']
            if len(explanation) > 150:
                explanation = question_data['explanation'][:150] + "..."

            # M√©langer les options
            original_options = question_data['options'].copy()
            original_correct_id = question_data['correct_option_id']
            correct_answer = original_options[original_correct_id]

            options_with_indices = list(enumerate(original_options))
            random.shuffle(options_with_indices)

            shuffled_options = []
            new_correct_id = 0

            for new_index, (old_index, option) in enumerate(options_with_indices):
                shuffled_options.append(option)
                if old_index == original_correct_id:
                    new_correct_id = new_index

            # Envoyer le poll
            poll_message = await context.bot.send_poll(
                chat_id=group_id,
                question=f"‚ùì Q{current_q + 1}/{session['total_questions']} - {question_text}",
                options=shuffled_options,
                type=Poll.QUIZ,
                correct_option_id=new_correct_id,
                explanation=explanation,
                is_anonymous=False,
                allows_multiple_answers=False,
                open_period=30
            )

            # Sauvegarder le poll actif
            self.bot_state.active_polls[poll_message.poll.id] = {
                'group_id': group_id,
                'question_number': current_q + 1,
                'correct_option_id': new_correct_id
            }

            # Programmer la question suivante ou la fin
            if current_q + 1 < session['total_questions']:
                asyncio.create_task(self._delayed_next_question(context, group_id))
            else:
                asyncio.create_task(self._delayed_quiz_end(context, group_id))

            logger.info(f"Question {current_q + 1} envoy√©e au groupe {group_id}")

        except Exception as e:
            logger.error(f"Erreur envoi question: {e}")
    
    async def _delayed_next_question(self, context: ContextTypes.DEFAULT_TYPE, group_id: int):
        """Envoie la prochaine question apr√®s 32 secondes."""
        await asyncio.sleep(32)
        await self._send_next_question(context, group_id)
    
    async def _delayed_quiz_end(self, context: ContextTypes.DEFAULT_TYPE, group_id: int):
        """Termine le quiz apr√®s 32 secondes."""
        await asyncio.sleep(32)
        await self.end_quiz(context, group_id)
    
    async def _send_next_question(self, context: ContextTypes.DEFAULT_TYPE, group_id: int):
        """Passe √† la question suivante."""
        if group_id in self.bot_state.quiz_sessions:
            self.bot_state.quiz_sessions[group_id]['current_question'] += 1
            await self.send_quiz_question(context, group_id)
    
    async def end_quiz(self, context: ContextTypes.DEFAULT_TYPE, group_id: int):
        """Termine le quiz et affiche les r√©sultats."""
        try:
            if group_id not in self.bot_state.quiz_sessions:
                return

            session = self.bot_state.quiz_sessions[group_id]
            participants = session['participants']

            if not participants:
                await context.bot.send_message(
                    chat_id=group_id,
                    text="üéØ QUIZ TERMIN√â üéØ\n\n‚ùå Aucune participation enregistr√©e."
                )
            else:
                # Cr√©er le classement pour ce quiz
                results = []
                for user_id in participants:
                    score = self.bot_state.group_scores[group_id].get(user_id, 0)
                    try:
                        user = await context.bot.get_chat_member(group_id, user_id)
                        name = user.user.first_name or "Utilisateur"
                    except:
                        name = "Utilisateur"

                    results.append((name, score))

                # Trier par score d√©croissant
                results.sort(key=lambda x: x[1], reverse=True)

                result_text = "üèÜ R√âSULTATS DU QUIZ üèÜ\n\n"

                for i, (name, score) in enumerate(results[:5]):  # Top 5
                    if i == 0:
                        emoji = "ü•á"
                    elif i == 1:
                        emoji = "ü•à" 
                    elif i == 2:
                        emoji = "ü•â"
                    else:
                        emoji = f"{i+1}."

                    result_text += f"{emoji} {name} - {score} points\n"

                result_text += f"\nüí´ {len(participants)} participants au total"

                await context.bot.send_message(chat_id=group_id, text=result_text)

            # Nettoyer la session
            del self.bot_state.quiz_sessions[group_id]

            logger.info(f"Quiz termin√© pour le groupe {group_id}")

        except Exception as e:
            logger.error(f"Erreur fin de quiz: {e}")

class UITexts:
    """Classe contenant tous les textes et claviers de l'interface utilisateur."""
    
    @staticmethod
    def get_main_menu_text() -> str:
        """Retourne le texte du menu principal."""
        return (
            "üéì BOT √âDUCATIF - BACCALAUR√âAT TCHAD üáπüá©\n\n"
            "üìö Bienvenue ! Ce bot vous accompagne dans vos r√©visions :\n\n"
            "üì• T√©l√©chargez des cours par s√©rie\n"
            "üí° Recevez des conseils d'√©tudes personnalis√©s\n"
            "üéØ Motivez-vous avec des citations inspirantes\n\n"
            "‚ú® Choisissez une option ci-dessous :"
        )
    
    @staticmethod
    def get_main_menu_keyboard() -> InlineKeyboardMarkup:
        """Retourne le clavier du menu principal."""
        keyboard = [
            [InlineKeyboardButton("üì• T√©l√©charger cours", callback_data="menu_pdfs")],
            [InlineKeyboardButton("üí° Conseils d'√©tudes", callback_data="conseils_etudes")],
            [InlineKeyboardButton("üéØ Citation motivante", callback_data="citation_motivante")],
            [InlineKeyboardButton("üë• Ajouter le bot √† votre groupe", url="https://t.me/Kabroedu_bot?startgroup=true")],
            [InlineKeyboardButton("‚ùì Aide", callback_data="help")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_subscription_keyboard(required_channel: str, required_group: str) -> InlineKeyboardMarkup:
        """Retourne le clavier de v√©rification d'abonnement."""
        return InlineKeyboardMarkup([
            [InlineKeyboardButton("üì¢ Rejoindre le Canal", url=f"https://t.me/{required_channel[1:]}")],
            [InlineKeyboardButton("üë• Rejoindre le Groupe", url=f"https://t.me/{required_group[1:]}")],
            [InlineKeyboardButton("üîÑ V√©rifier √† nouveau", callback_data="check_subscription")]
        ])

class EducationalBot:
    """Classe principale du bot √©ducatif."""
    
    def __init__(self):
        self.state = BotState()
        self.subscription_manager = SubscriptionManager(self.state)
        self.data_manager = DataManager(self.state)
        self.quiz_manager = QuizManager(self.state)
        self.ui_texts = UITexts()
        
        # T√¢che de sauvegarde p√©riodique
        self.save_task = None
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Commande /start."""
        chat_type = update.effective_chat.type
        user_id = update.effective_user.id

        if chat_type == ChatType.PRIVATE:
            # V√©rifier l'abonnement en priv√© uniquement
            is_subscribed, subscription_message = await self.subscription_manager.check_user_subscription(context, user_id)
            if not is_subscribed:
                keyboard = self.ui_texts.get_subscription_keyboard(
                    self.state.REQUIRED_CHANNEL, 
                    self.state.REQUIRED_GROUP
                )
                await update.message.reply_text(subscription_message, reply_markup=keyboard)
                return

            # Mode priv√© - t√©l√©chargement de cours
            await update.message.reply_text(
                self.ui_texts.get_main_menu_text(),
                reply_markup=self.ui_texts.get_main_menu_keyboard()
            )

        else:
            # Mode groupe - pas de v√©rification d'abonnement n√©cessaire
            group_id = update.effective_chat.id
            if group_id not in self.state.group_scores:
                self.state.group_scores[group_id] = {}

            # Ajouter le groupe aux groupes actifs
            self.state.active_groups.add(group_id)
            self.data_manager.save_active_groups()

            start_text = (
                "üéØ QUIZ √âDUCATIF ACTIV√â DANS CE GROUPE üéØ\n\n"
                "üìö Quiz d'Histoire-G√©ographie avec options m√©lang√©es !\n"
                "üåü Gagnez des points en r√©pondant correctement\n"
                "üèÜ Scores individuels dans ce groupe\n"
                "üïò Quiz quotidien automatique √† 21h00\n\n"
                "Commandes disponibles :\n"
                "‚Ä¢ /quiz - D√©marrer un quiz de 3 questions\n"  
                "‚Ä¢ /scores - Voir le classement du groupe\n"
                "‚Ä¢ /cours - T√©l√©charger des cours PDF\n"
                "‚Ä¢ /conseil - Recevoir un conseil d'√©tude\n"
                "‚Ä¢ /motivation - Citation motivante\n"
                "‚Ä¢ /planning - Suggestion de planning\n\n"
                "üéì Bonne chance dans vos r√©visions !"
            )

            await update.message.reply_text(start_text)
    
    async def quiz_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Commande /quiz."""
        chat_type = update.effective_chat.type
        user_id = update.effective_user.id

        # V√©rifier l'abonnement seulement en priv√©
        if chat_type == ChatType.PRIVATE:
            is_subscribed, subscription_message = await self.subscription_manager.check_user_subscription(context, user_id)
            if not is_subscribed:
                await update.message.reply_text(subscription_message)
                return

            await update.message.reply_text(
                "‚ùå Quiz non disponible en priv√©\n\n"
                "üì• Les quiz sont r√©serv√©s aux groupes.\n"
                "üí° Utilisez les boutons ci-dessous pour t√©l√©charger des cours :",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üì• T√©l√©charger cours", callback_data="menu_pdfs")]
                ])
            )
            return

        # D√©marrer le quiz dans le groupe
        group_id = update.effective_chat.id
        await self.quiz_manager.start_quiz_in_group(context, group_id, update.message)
    
    async def scores_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Commande /scores."""
        chat_type = update.effective_chat.type

        if chat_type == ChatType.PRIVATE:
            await update.message.reply_text(
                "‚ùå Scores non disponibles en priv√©\n\n"
                "üìä Les scores sont sp√©cifiques √† chaque groupe."
            )
            return

        group_id = update.effective_chat.id

        if group_id not in self.state.group_scores or not self.state.group_scores[group_id]:
            await update.message.reply_text(
                "üìä AUCUN SCORE ENREGISTR√â üìä\n\n"
                "üéØ Participez √† un quiz avec /quiz pour appara√Ætre dans le classement !"
            )
            return

        # Cr√©er le classement
        results = []
        for user_id, score in self.state.group_scores[group_id].items():
            try:
                user = await context.bot.get_chat_member(group_id, user_id)
                name = user.user.first_name or "Utilisateur"
            except:
                name = "Utilisateur"

            results.append((name, score))

        # Trier par score d√©croissant
        results.sort(key=lambda x: x[1], reverse=True)

        scores_text = "üèÜ CLASSEMENT DU GROUPE üèÜ\n\n"

        for i, (name, score) in enumerate(results[:10]):  # Top 10
            if i == 0:
                emoji = "üëë"
            elif i == 1:
                emoji = "ü•à"
            elif i == 2:
                emoji = "ü•â"
            else:
                emoji = f"{i+1}."

            scores_text += f"{emoji} {name} - {score} points\n"

        scores_text += f"\nüìä {len(results)} participants au total"

        await update.message.reply_text(scores_text)
    
    async def handle_poll_answer(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """G√®re les r√©ponses aux polls de quiz."""
        poll_answer = update.poll_answer
        poll_id = poll_answer.poll_id
        user_id = poll_answer.user.id

        if poll_id not in self.state.active_polls:
            return

        poll_info = self.state.active_polls[poll_id]
        group_id = poll_info['group_id']
        correct_option_id = poll_info['correct_option_id']

        if group_id not in self.state.quiz_sessions:
            return

        # Ajouter le participant
        self.state.quiz_sessions[group_id]['participants'].add(user_id)

        # Initialiser le score de l'utilisateur pour ce groupe
        if user_id not in self.state.group_scores[group_id]:
            self.state.group_scores[group_id][user_id] = 0

        # V√©rifier si la r√©ponse est correcte
        if poll_answer.option_ids and poll_answer.option_ids[0] == correct_option_id:
            self.state.group_scores[group_id][user_id] += 1
            logger.info(f"Utilisateur {user_id} a r√©pondu correctement dans le groupe {group_id}")
    
    async def daily_quiz_job(self, context: ContextTypes.DEFAULT_TYPE):
        """Job qui lance le quiz quotidien √† 21h00."""
        try:
            await self._cleanup_inactive_groups(context)
            
            if not self.state.active_groups:
                logger.info("Aucun groupe actif pour le quiz quotidien")
                return

            quiz_message = (
                "üåô QUIZ QUOTIDIEN - 21H00 üåô\n\n"
                "üéØ L'heure du quiz quotidien est arriv√©e !\n"
                "üìö 3 questions d'Histoire-G√©ographie\n"
                "üåü 1 point par bonne r√©ponse\n"
                "‚è∞ 30 secondes par question\n\n"
                "üöÄ Le quiz commence dans 10 secondes..."
            )

            successful_groups = 0
            for group_id in self.state.active_groups.copy():
                try:
                    if group_id not in self.state.quiz_sessions:
                        await context.bot.send_message(chat_id=group_id, text=quiz_message)
                        await asyncio.sleep(10)
                        await self.quiz_manager.start_quiz_in_group(context, group_id, is_daily=True)
                        successful_groups += 1
                except Exception as e:
                    logger.error(f"Erreur envoi quiz quotidien groupe {group_id}: {e}")
                    self.state.active_groups.discard(group_id)

            logger.info(f"Quiz quotidien lanc√© dans {successful_groups}/{len(self.state.active_groups)} groupes")

        except Exception as e:
            logger.error(f"Erreur job quiz quotidien: {e}")
    
    async def _cleanup_inactive_groups(self, context: ContextTypes.DEFAULT_TYPE):
        """Nettoie la liste des groupes actifs."""
        inactive_groups = set()
        
        for group_id in self.state.active_groups.copy():
            try:
                await context.bot.get_chat(group_id)
            except Exception:
                logger.info(f"Groupe {group_id} inaccessible, suppression de la liste active")
                inactive_groups.add(group_id)
        
        self.state.active_groups -= inactive_groups
        
        if inactive_groups:
            logger.info(f"Nettoyage termin√© : {len(inactive_groups)} groupes supprim√©s")
    
    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """G√®re tous les callbacks du bot."""
        query = update.callback_query
        await query.answer()
        data = query.data

        # Gestion des PDF
        if data == "menu_pdfs":
            await self.state.pdf_manager.send_pdf_menu(query, context)
        elif data.startswith("pdf_serie_"):
            serie = data.replace("pdf_serie_", "")
            await self.state.pdf_manager.send_serie_subjects(query, context, serie)
        elif data.startswith("pdf_download"):
            action, serie, subject = self.state.pdf_manager.parse_callback_data(data)
            if action == "download_all":
                await self.state.pdf_manager.send_all_pdfs(query, context, serie)
            elif action == "download" and subject:
                await self.state.pdf_manager.send_pdf(query, context, serie, subject)

        # Autres callbacks
        elif data == "conseils_etudes":
            await self._conseils_etudes_callback(query)
        elif data == "citation_motivante":
            await self._citation_motivante_callback(query)
        elif data == "help":
            await self._help_callback(query)
        elif data == "back_menu":
            await self._back_menu_callback(query)
        elif data == "check_subscription":
            await self._check_subscription_callback(query, context)
    
    async def _conseils_etudes_callback(self, query):
        """Affiche des conseils d'√©tudes."""
        conseils = [
            "üìö Lisez activement en prenant des notes",
            "üïê R√©visez r√©guli√®rement, pas au dernier moment", 
            "üéØ Fixez-vous des objectifs r√©alisables",
            "üí° Expliquez √† quelqu'un d'autre ce que vous apprenez",
            "‚è∞ Faites des pauses pour mieux m√©moriser"
        ]

        conseil = random.choice(conseils)

        conseil_text = (
            "üí° CONSEIL D'√âTUDE üí°\n\n"
            f"{conseil}\n\n"
            "üéØ Mettez ce conseil en pratique d√®s aujourd'hui !"
        )

        keyboard = [
            [InlineKeyboardButton("üîÑ Autre conseil", callback_data="conseils_etudes")],
            [InlineKeyboardButton("üì• T√©l√©charger cours", callback_data="menu_pdfs")]
        ]

        await query.edit_message_text(conseil_text, reply_markup=InlineKeyboardMarkup(keyboard))
    
    async def _citation_motivante_callback(self, query):
        """Affiche une citation motivante."""
        quote = random.choice(self.state.motivational_quotes)

        motivation_text = (
            "üåü MOTIVATION DU JOUR üåü\n\n"
            f"{quote}\n\n"
            "üéì Continuez vos efforts, le succ√®s vous attend !"
        )

        keyboard = [
            [InlineKeyboardButton("üîÑ Autre citation", callback_data="citation_motivante")],
            [InlineKeyboardButton("üì• T√©l√©charger cours", callback_data="menu_pdfs")]
        ]

        await query.edit_message_text(motivation_text, reply_markup=InlineKeyboardMarkup(keyboard))
    
    async def _help_callback(self, query):
        """Affiche l'aide depuis le callback."""
        help_text = (
            "‚ÑπÔ∏è AIDE - BOT √âDUCATIF ‚ÑπÔ∏è\n\n"
            "üì• Cours gratuits :\n"
            "‚Ä¢ Toutes mati√®res des s√©ries A4, C, D\n"
            "‚Ä¢ PDF t√©l√©chargeables instantan√©ment\n\n"
            "üéØ Quiz en groupe :\n"  
            "‚Ä¢ Ajoutez-moi √† votre groupe d'√©tude\n"
            "‚Ä¢ Quiz d'Histoire-G√©ographie\n"
            "‚Ä¢ Syst√®me de points par groupe\n\n"
            "‚úÖ Tout est gratuit et sans limite !"
        )

        await query.edit_message_text(
            help_text,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üì• T√©l√©charger cours", callback_data="menu_pdfs")]])
        )
    
    async def _back_menu_callback(self, query):
        """Retour au menu principal."""
        await query.edit_message_text(
            self.ui_texts.get_main_menu_text(),
            reply_markup=self.ui_texts.get_main_menu_keyboard()
        )
    
    async def _check_subscription_callback(self, query, context):
        """Callback pour re-v√©rifier l'abonnement."""
        user_id = query.from_user.id
        is_subscribed, subscription_message = await self.subscription_manager.check_user_subscription(context, user_id)

        if is_subscribed:
            start_text = "‚úÖ ABONNEMENT V√âRIFI√â ! ‚úÖ\n\n" + self.ui_texts.get_main_menu_text()
            try:
                await query.edit_message_text(start_text, reply_markup=self.ui_texts.get_main_menu_keyboard())
            except Exception as e:
                if "Message is not modified" in str(e):
                    await query.message.reply_text(start_text, reply_markup=self.ui_texts.get_main_menu_keyboard())
                    await query.answer("‚úÖ V√©rification r√©ussie !")
                else:
                    logger.error(f"Erreur modification message: {e}")
        else:
            keyboard = self.ui_texts.get_subscription_keyboard(self.state.REQUIRED_CHANNEL, self.state.REQUIRED_GROUP)
            try:
                await query.edit_message_text(subscription_message, reply_markup=keyboard)
            except Exception as e:
                if "Message is not modified" in str(e):
                    await query.answer("‚ö†Ô∏è Veuillez d'abord vous abonner")
                else:
                    logger.error(f"Erreur modification message: {e}")
    
    async def conseil_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Commande /conseil."""
        chat_type = update.effective_chat.type
        user_id = update.effective_user.id

        if chat_type == ChatType.PRIVATE:
            is_subscribed, subscription_message = await self.subscription_manager.check_user_subscription(context, user_id)
            if not is_subscribed:
                await update.message.reply_text(subscription_message)
                return
            
        conseils = [
            "üìö Conseil d'√©tude : Lisez activement en prenant des notes manuscrites",
            "üïê Conseil d'√©tude : R√©visez r√©guli√®rement, pas au dernier moment", 
            "üéØ Conseil d'√©tude : Fixez-vous des objectifs r√©alisables quotidiennement",
            "üí° Conseil d'√©tude : Expliquez √† quelqu'un d'autre ce que vous apprenez",
            "‚è∞ Conseil d'√©tude : Faites des pauses de 10 min toutes les heures",
            "üß† Conseil d'√©tude : Variez les mati√®res pour stimuler votre cerveau",
            "üìñ Conseil d'√©tude : Cr√©ez des fiches de r√©vision color√©es",
            "üåÖ Conseil d'√©tude : √âtudiez le matin quand votre esprit est frais"
        ]

        conseil = random.choice(conseils)
        await update.message.reply_text(conseil)
    
    async def motivation_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Commande /motivation."""
        chat_type = update.effective_chat.type
        user_id = update.effective_user.id

        if chat_type == ChatType.PRIVATE:
            is_subscribed, subscription_message = await self.subscription_manager.check_user_subscription(context, user_id)
            if not is_subscribed:
                await update.message.reply_text(subscription_message)
                return
            
        quote = random.choice(self.state.motivational_quotes)

        motivation_text = (
            "üåü MOTIVATION DU JOUR üåü\n\n"
            f"{quote}\n\n"
            "üéì Continuez vos efforts, le succ√®s vous attend !"
        )

        await update.message.reply_text(motivation_text)
    
    async def planning_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Commande /planning."""
        chat_type = update.effective_chat.type
        user_id = update.effective_user.id

        if chat_type == ChatType.PRIVATE:
            is_subscribed, subscription_message = await self.subscription_manager.check_user_subscription(context, user_id)
            if not is_subscribed:
                await update.message.reply_text(subscription_message)
                return
            
        plannings = [
            (
                "üìÖ PLANNING SEMAINE INTENSIVE üìÖ\n\n"
                "üåÖ 06h-08h : Math√©matiques (esprit frais)\n"
                "üåû 09h-11h : Sciences (Physique/Chimie)\n"
                "‚òÄÔ∏è 14h-16h : Fran√ßais/Philosophie\n"
                "üåÜ 17h-19h : Histoire/G√©ographie\n"
                "üåô 20h-21h : R√©visions g√©n√©rales"
            ),
            (
                "üìÖ PLANNING √âQUILIBR√â üìÖ\n\n"
                "üìö Lundi : Math√©matiques + Fran√ßais\n"
                "üî¨ Mardi : Sciences + Anglais\n"
                "üèõÔ∏è Mercredi : Histoire + G√©ographie\n"
                "ü§î Jeudi : Philosophie + SVT\n"
                "üìñ Vendredi : R√©visions mixtes\n"
                "üéØ Weekend : Tests et exercices"
            ),
            (
                "üìÖ PLANNING EXPRESS (2h/jour) üìÖ\n\n"
                "‚è∞ 45 min : Mati√®re principale\n"
                "‚è∞ 30 min : Mati√®re secondaire\n"
                "‚è∞ 15 min : R√©visions rapides\n"
                "‚è∞ 30 min : Exercices pratiques\n\n"
                "üí° Astuce : Alternez les mati√®res chaque jour"
            )
        ]

        planning = random.choice(plannings)
        await update.message.reply_text(planning)
    
    async def cours_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Commande /cours."""
        chat_type = update.effective_chat.type
        user_id = update.effective_user.id

        if chat_type == ChatType.PRIVATE:
            is_subscribed, subscription_message = await self.subscription_manager.check_user_subscription(context, user_id)
            if not is_subscribed:
                await update.message.reply_text(subscription_message)
                return

            await update.message.reply_text(
                self.ui_texts.get_main_menu_text(),
                reply_markup=self.ui_texts.get_main_menu_keyboard()
            )
        else:
            cours_text = (
                "üìö T√âL√âCHARGEMENT DE COURS üìö\n\n"
                "üö´ Les t√©l√©chargements ne sont pas autoris√©s dans les groupes\n\n"
                "‚úÖ Pour t√©l√©charger vos cours :\n"
                "1Ô∏è‚É£ Contactez le bot en priv√© : @Kabroedu_bot\n"
                "2Ô∏è‚É£ Ou cliquez sur le bouton ci-dessous\n\n"
                "üìñ S√©ries disponibles :\n"
                "üìö A4 : Fran√ßais, Anglais, Histoire, G√©ographie, Maths, Philo\n"
                "üî¨ D : Sciences + mati√®res communes\n"
                "üìä C : Maths & Sciences + mati√®res communes\n\n"
                "üéì Tous les cours sont GRATUITS !"
            )

            keyboard = [
                [InlineKeyboardButton("üì• T√©l√©charger en priv√©", url="https://t.me/Kabroedu_bot?start=cours")]
            ]

            await update.message.reply_text(cours_text, reply_markup=InlineKeyboardMarkup(keyboard))
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Commande d'aide."""
        chat_type = update.effective_chat.type

        if chat_type == ChatType.PRIVATE:
            help_text = (
                "‚ÑπÔ∏è AIDE - BOT √âDUCATIF ‚ÑπÔ∏è\n\n"
                "üì• En priv√© :\n"
                "‚Ä¢ T√©l√©chargement de cours par s√©rie\n"
                "‚Ä¢ Conseils d'√©tudes personnalis√©s\n"
                "‚Ä¢ Citations motivantes\n\n"
                "üéØ Dans les groupes :\n"
                "‚Ä¢ Quiz d'Histoire-G√©ographie\n"
                "‚Ä¢ Syst√®me de points par groupe\n"
                "‚Ä¢ Classements s√©par√©s\n\n"
                "‚úÖ Ajoutez-moi dans votre groupe d'√©tude !"
            )
        else:
            help_text = (
                "‚ÑπÔ∏è AIDE - QUIZ DE GROUPE ‚ÑπÔ∏è\n\n"
                "üéØ Commandes disponibles :\n"
                "‚Ä¢ /quiz - D√©marrer un quiz de 3 questions\n"
                "‚Ä¢ /scores - Voir le classement du groupe\n"
                "‚Ä¢ /conseil - Recevoir un conseil d'√©tude\n"
                "‚Ä¢ /motivation - Citation motivante\n"
                "‚Ä¢ /planning - Suggestion de planning\n"
                "‚Ä¢ /cours - T√©l√©charger des cours PDF\n"
                "‚Ä¢ /start - Informations sur le bot\n\n"
                "üìö Fonctionnement :\n"
                "‚Ä¢ Questions d'Histoire-G√©ographie m√©lang√©es\n"
                "‚Ä¢ 30 secondes par question\n"
                "‚Ä¢ 1 point par bonne r√©ponse\n"
                "‚Ä¢ Quiz quotidien automatique √† 21h00\n"
                "‚Ä¢ Scores s√©par√©s par groupe\n\n"
                "üí° Astuce : Utilisez /cours pour t√©l√©charger des PDF directement !"
            )

        await update.message.reply_text(help_text)
    
    def setup_daily_quiz_job(self, application: Application):
        """Configure le job quotidien de quiz √† 21h00."""
        try:
            chad_tz = pytz.timezone('Africa/Ndjamena')
            job_queue = application.job_queue
            
            if job_queue:
                job_queue.run_daily(
                    self.daily_quiz_job,
                    time=time(21, 0, 0, tzinfo=chad_tz),
                    days=(0, 1, 2, 3, 4, 5, 6),
                    data="daily_quiz",
                    name="daily_quiz_job"
                )
                logger.info("Job quotidien configur√© pour 21h00 (heure du Tchad)")
            else:
                logger.warning("JobQueue non disponible - quiz quotidien d√©sactiv√©")

        except Exception as e:
            logger.error(f"Erreur configuration job quotidien: {e}")
    
    async def run(self):
        """D√©marre le bot."""
        if not self.state.TELEGRAM_TOKEN:
            logger.error("‚ùå Veuillez configurer votre TOKEN Telegram !")
            return

        # Charger les donn√©es
        self.data_manager.load_questions()
        self.data_manager.load_motivational_quotes()
        self.data_manager.load_scores()
        self.data_manager.load_active_groups()

        # Cr√©er l'application
        application = Application.builder().token(self.state.TELEGRAM_TOKEN).build()

        try:
            # Commandes
            application.add_handler(CommandHandler("start", self.start_command))
            application.add_handler(CommandHandler("help", self.help_command))
            application.add_handler(CommandHandler("quiz", self.quiz_command))
            application.add_handler(CommandHandler("scores", self.scores_command))
            application.add_handler(CommandHandler("cours", self.cours_command))
            application.add_handler(CommandHandler("conseil", self.conseil_command))
            application.add_handler(CommandHandler("motivation", self.motivation_command))
            application.add_handler(CommandHandler("planning", self.planning_command))

            # Callbacks et polls
            application.add_handler(CallbackQueryHandler(self.handle_callback))
            application.add_handler(PollAnswerHandler(self.handle_poll_answer))

            # Configurer le quiz quotidien automatique
            self.setup_daily_quiz_job(application)

            logger.info("üöÄ Bot √©ducatif d√©marr√© avec succ√®s !")
            print("üöÄ Bot √©ducatif d√©marr√© avec succ√®s !")
            print("üìö Fonctionnalit√©s disponibles :")
            print("   ‚Ä¢ T√©l√©chargement de cours (priv√© + groupes)")
            print("   ‚Ä¢ Quiz d'Histoire-G√©ographie avec options m√©lang√©es")
            print("   ‚Ä¢ Quiz quotidien automatique √† 21h00")
            print("   ‚Ä¢ Scores s√©par√©s par groupe avec sauvegarde p√©riodique")
            print("   ‚Ä¢ Plus de 500 citations motivantes")
            print(f"üìä Scores charg√©s pour {len(self.state.group_scores)} groupes")
            print(f"üë• {len(self.state.active_groups)} groupes actifs")

            # D√©marrer la t√¢che de sauvegarde p√©riodique
            self.save_task = asyncio.create_task(self.data_manager.periodic_save())

            # D√©marrer le bot avec run_polling (m√©thode recommand√©e)
            await application.run_polling(
                poll_interval=1.0,
                timeout=10,
                bootstrap_retries=5,
                read_timeout=2,
                write_timeout=2
            )
            
        except KeyboardInterrupt:
            logger.info("Arr√™t du bot demand√© par l'utilisateur")
        except Exception as e:
            logger.error(f"Erreur critique au d√©marrage : {e}")
            print(f"‚ùå Erreur au d√©marrage : {e}")
        finally:
            # Arr√™ter la t√¢che de sauvegarde et sauvegarder une derni√®re fois
            if self.save_task:
                self.save_task.cancel()
            logger.info("Sauvegarde finale des donn√©es...")
            self.data_manager.save_scores()
            self.data_manager.save_active_groups()
            logger.info("Donn√©es sauvegard√©es avec succ√®s")

async def main():
    """Point d'entr√©e principal."""
    bot = EducationalBot()
    await bot.run()

if __name__ == '__main__':
    asyncio.run(main())
